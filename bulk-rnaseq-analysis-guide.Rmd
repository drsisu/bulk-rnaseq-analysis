---
title: "Bulk RNA-seq data processing and differential gene expression analysis pipeline"
author: Erick Lu
output: 
  html_document:
    toc: true
---

## Introduction

Here, I present a complete bulk RNA-sequencing pipeline, including:

1. Finding and downloading the raw data using SRA tools
2. Mapping FASTQ files using STAR
3. Differential gene analysis using DESeq2
4. Visualizations for Bulk RNA-sequencing


## Obtaining the raw data

### Data repository at GSE106305

The raw data is available at: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE106305. There are several samples associated with this study, and we will only be focusing on the following samples:

Sample Name | GSM Identifier | SRA Identifier (SRX) | SRA Runs (SRR, download these)
------------------ | ----------------- | -------------------------- | --------------------------------------------------------
LNCaP_RNA-Seq_Empty_Vector_Normoxia_rep1 | GSM3145509 | SRX4096735 | SRR7179504, SRR7179505, SRR7179506, and SRR7179507
LNCaP_RNA-Seq_Empty_Vector_Normoxia_rep2 | GSM3145510 | SRX4096736 | SRR7179508, SRR7179509, SRR7179510, and SRR7179511
LNCaP_RNA-Seq_Empty_Vector_Hypoxia_rep1 | GSM3145513 | SRX4096739 | SRR7179520, SRR7179521, SRR7179522, and SRR7179523
LNCaP_RNA-Seq_Empty_Vector_Hypoxia_rep2 | GSM3145514 | SRX4096740 | SRR7179524, SRR7179525, SRR7179526, and SRR7179527
PC3_RNA-Seq_siCtrl_Normoxia_rep1 | GSM3145517 | SRX4096743 | SRR7179536
PC3_RNA-Seq_siCtrl_Normoxia_rep2 | GSM3145518 | SRX4096744 | SRR7179537
PC3_RNA-Seq_siCtrl_Hypoxia_rep1 | GSM3145521 | SRX4096747 | SRR7179540
PC3_RNA-Seq_siCtrl_Hypoxia_rep2 | GSM3145522 | SRX4096748 | SRR7179541

We have selected the control samples for both cell lines (Empty Vector for LNCaP and siCtrl for PC3) in conditions of either normoxia or hypoxia. This will allow us to analyze the LNCaP and PC3 cell lines for their gene expression changes in response to hypoxia, and compare which pathways are commonly upregulated/downregulated by both lines.

Each of the samples above have an associated SRA accession number, indicated above. These SRA accessions are used to download the raw sequencing data. To eventually get the raw data in FASTQ format, we first need to first download the SRA files (`.sra`) associated with each sample.

### Downloading FASTQ files using SRA toolkit

In order to download the SRA files onto your machine, we use the NCBI's SRA toolkit, which lets us use the command line to download a specified SRA accession ID. You can read more about SRA toolkit here: https://www.ncbi.nlm.nih.gov/books/NBK242621/.

The toolkit works by first using the `prefetch` command to download the SRA file associated with the specified SRA ID. The SRA file contains a set of "instructions" for downloading the sequencing data associated with the SRA ID from NCBI. A sample command would be: `prefetch SRR7179504`. This will download the file `SRR7179504.sra` into your home directory at ~/ncbi/public/sra/.

After you have downloaded the SRA file, you can use `fastq-dump` to extract the contents of it into a `.fastq` file. The Edwards lab at SDSU provides a nice tutorial for how to use fastq-dump here: https://edwards.sdsu.edu/research/fastq-dump/. A sample command would be: 

```bash
fastq-dump --outdir fastq --gzip --skip-technical  --readids --read-filter pass --dumpbase --split-3 --clip ~/ncbi/public/sra/SRR7179504.sra
```

Since there are lots of SRA files associated with our samples, it would take a long time to manually run `prefetch` and `fastq-dump` for all the files. To automate all the downloads, I wrote a small script in python to call `fastq-dump` on each of the SRA IDs we want. The code is shown below as well as provided in this repo as `fastq_download.py`:

```py
import subprocess

sra_numbers = [
    "SRR7179504", "SRR7179505", "SRR7179506", "SRR7179507",
    "SRR7179508", "SRR7179509", "SRR7179510", "SRR7179511",
    "SRR7179520", "SRR7179521", "SRR7179522", "SRR7179523",
    "SRR7179524", "SRR7179525", "SRR7179526", "SRR7179527",
    "SRR7179536", "SRR7179537", "SRR7179540","SRR7179541"
    ]

# this will download the .sra files to ~/ncbi/public/sra/ (will create directory if not present)
for sra_id in sra_numbers:
    print ("Currently downloading: " + sra_id)
    prefetch = "prefetch " + sra_id
    print ("The command used was: " + prefetch)
    subprocess.call(prefetch, shell=True)

# this will extract the .sra files from above into a folder named 'fastq'
for sra_id in sra_numbers:
    print ("Generating fastq for: " + sra_id)
    fastq_dump = "fastq-dump --outdir fastq --gzip --skip-technical  --readids --read-filter pass --dumpbase --split-3 --clip ~/ncbi/public/sra/" + sra_id + ".sra"
    print ("The command used was: " + fastq_dump)
    subprocess.call(fastq_dump, shell=True)
```

We can run the python script by simply navigating to the folder on your machine where you want to store the fastq files (via the command line), then running `python fastq_download.py`. This should work in python 2 and python 3. After running the python script, our .fastq files should all be sitting in a directory called 'fastq'.

### Concatenating FASTQ files

For samples such as LNCaP_RNA-Seq_Empty_Vector_Normoxia_rep1, there are four resulting fastq files containing the sequencing data. We can concatenate these four files into one file by using `cat` in the command line and storing the output into a new fastq file. Below, I perform the concatenation for each of the LNCaP samples, and :

```bash
cat SRR7179504_pass.fastq.gz SRR7179505_pass.fastq.gz SRR7179506_pass.fastq.gz SRR7179507_pass.fastq.gz  > LNCAP_Normoxia_S1.fastq.gz
cat SRR7179508_pass.fastq.gz SRR7179509_pass.fastq.gz SRR7179510_pass.fastq.gz SRR7179511_pass.fastq.gz  > LNCAP_Normoxia_S2.fastq.gz
cat SRR7179520_pass.fastq.gz SRR7179521_pass.fastq.gz SRR7179522_pass.fastq.gz SRR7179523_pass.fastq.gz  > LNCAP_Hypoxia_S1.fastq.gz
cat SRR7179524_pass.fastq.gz SRR7179525_pass.fastq.gz SRR7179526_pass.fastq.gz SRR7179527_pass.fastq.gz  > LNCAP_Hypoxia_S2.fastq.gz
```

In contrast, there is only one fastq file for each of the PC3 samples. We can just rename them from their SRR identifiers to their real sample names using `mv`:

```bash
mv SRR7179536_pass.fastq.gz PC3_Normoxia_S1.fastq.gz
mv SRR7179537_pass.fastq.gz PC3_Normoxia_S2.fastq.gz
mv SRR7179540_pass.fastq.gz PC3_Hypoxia_S1.fastq.gz
mv SRR7179541_pass.fastq.gz PC3_Hypoxia_S2.fastq.gz
```

## Aligning reads using STAR

Each read in your fastq file must be "mapped" to a reference genome. Mapping can be described as finding the place in the reference genome that best matches the fragment of an mRNA transcript captured in the read. In this section, I will describe the concepts behind mapping reads to a reference genome, and how to do it using the tool STAR and some python scripting.

### The concepts behind mapping reads

In order to perform bulk RNA-sequencing, a "library" must first be prepared from the cells of interest and this library is what is sequenced to create the fastq files. To create a library, mRNA from the cells is captured and reverse transcribed into cDNA. This is then fragmented into small pieces, and sequencing adaptors are ligated to the ends of each fragment to create the "library". The resulting fastq file contains the sequences of all these tiny little fragments. Using the sequence for each fragment (a "read"), we can then try to figure out from which part of the genome that fragment came from, and subsequently which gene was being transcribed to create the original mRNA that was captured. Counting the number of times a "read" mapped to a specific gene gives us information about how "high" or "low" a gene was being expressed.

### STAR

A great RNA-seq alignment tool is STAR (Spliced Transcripts Alignment to a Reference, https://github.com/alexdobin/STAR). In order to install STAR, follow the installation instructions provided in the github repo for the platform you are using.

#### building human genome index using genomeGenerate

Once STAR is installed, we first need to build a genome index. In our case, we need to use the human reference genome since we are analyzing RNA-seq data from human cells. We have to supply STAR with the human reference genome sequence (FASTA) and annotation (GTF) files, from which STAR will make genome index files.

We can download the FASTA and GTF files from the ensembl website (https://uswest.ensembl.org/Homo_sapiens/Info/Index) or using the command line:

```bash
wget ftp://ftp.ensembl.org/pub/release-99/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.primary_assembly.fa.gz
wget ftp://ftp.ensembl.org/pub/release-99/gtf/homo_sapiens/Homo_sapiens.GRCh38.99.gtf.gz
gunzip *.gz
```

Once these are downloaded and unzipped, we can run the STAR genomeGenerate command below to make the genome index file. For the genomeDir parameter, you can specify the directory where you are keeping the FASTA and GTF files.

```bash
STAR --runThreadN 64 --runMode genomeGenerate --genomeDir /data/genomes/h38/STAR/ --genomeFastaFiles /data/genomes/h38/STAR/Homo_sapiens.GRCh38.dna.primary_assembly.fa --sjdbGTFfile /data/genomes/h38/STAR/Homo_sapiens.GRCh38.99.gtf
```

The output from successfully running the command looks like:

```{}
Feb 15 20:06:34 ..... started STAR run
Feb 15 20:06:34 ... starting to generate Genome files
Feb 15 20:07:28 ... starting to sort Suffix Array. This may take a long time...
Feb 15 20:07:41 ... sorting Suffix Array chunks and saving them to disk...
Feb 15 20:20:11 ... loading chunks from disk, packing SA...
Feb 15 20:21:15 ... finished generating suffix array
Feb 15 20:21:15 ... generating Suffix Array index
Feb 15 20:25:16 ... completed Suffix Array index
Feb 15 20:25:16 ..... processing annotations GTF
Feb 15 20:25:26 ..... inserting junctions into the genome indices
Feb 15 20:27:58 ... writing Genome to disk ...
Feb 15 20:28:01 ... writing Suffix Array to disk ...
Feb 15 20:28:18 ... writing SAindex to disk
Feb 15 20:28:20 ..... finished successfully
```

After running the command, you should see a bunch of genome index files in the directory specified by genomeDir. Now, we can start mapping reads from our FASTQ files, which I will explain in the next section.

#### mapping reads

An example STAR command used to map a single sample, LNCAP_Normoxia_S1_R1_001.fastq.gz, to the reference genome that we just built is:

```bash
STAR --runThreadN 64 --genomeDir /data/genomes/h38/STAR --outFilterType BySJout --outFilterMismatchNoverLmax 0.04 --outFilterMismatchNmax 999 --alignSJDBoverhangMin 1 --alignSJoverhangMin 8 --outFilterMultimapNmax 20 --alignIntronMin 20 --alignIntronMax 1000000 --alignMatesGapMax 1000000 --readFilesIn /fastq/LNCAP_Normoxia_S1_R1_001.fastq.gz --clip3pAdapterSeq GATCGGAAGAGCACACGTCTGAACTCCAGTCAC --outSAMtype BAM SortedByCoordinate --quantMode GeneCounts --outFileNamePrefix LNCAP_Normoxia_S1
```
Notice that I've plugged in the directory that contains the genome index files for `--genomeDir`, as well as the fastq file location for sample LNCAP_Normoxia_S1_R1_001.fastq.gz for `--readFilesIn` and also provided the sample name for `--outFileNamePrefix`.


Since we have 8 samples to run, and each sample will take a while to run, we can use a python script to run the command for each fastq in the directory:

```py
import subprocess
import os

# modify these variables based on where you store your data / genome index
output_directory = "STAR_output/"
genome_directory = "/data/genomes/h38/STAR/"
fastq_directory = "/data/analysis/hypoxia/fastq/"

os.mkdir(output_directory)
for fastq in os.listdir(fastq_directory):
    # only process files that end in fastq.gz
    if fastq.endswith('.fastq.gz'):
        prefix=fastq.strip(".fastq.gz") + "_output"
        # make an output folder for the current fastq file
        os.mkdir(output_directory + prefix)
        print ("Currently mapping: " + fastq)
        # run STAR on the current fastq file
        subprocess.call("STAR --runThreadN 64 --genomeDir " + genome_directory + " --readFilesCommand zcat --outFilterType BySJout --outFilterMismatchNoverLmax 0.04 --outFilterMismatchNmax 999 --alignSJDBoverhangMin 1 --alignSJoverhangMin 8 --outFilterMultimapNmax 20 --alignIntronMin 20 --alignIntronMax 1000000 --alignMatesGapMax 1000000 --readFilesIn "+ fastq_directory + fastq + " --clip3pAdapterSeq GATCGGAAGAGCACACGTCTGAACTCCAGTCAC --outSAMtype BAM SortedByCoordinate --quantMode GeneCounts --outFileNamePrefix " + output_directory + prefix + "/", shell=True)
```

The output of a successful STAR alignment looks like this, for one iteration of the loop:

```{}
Currently mapping: PC3_Normoxia_S1.fastq.gz
Feb 16 23:28:42 ..... started STAR run
Feb 16 23:28:42 ..... loading genome
Feb 16 23:28:59 ..... started mapping
Feb 16 23:31:07 ..... finished mapping
Feb 16 23:31:10 ..... started sorting BAM
Feb 16 23:32:59 ..... finished successfully
```

We can save the script as align_STAR.py, and run the script by simply typing `python align_STAR.py` in the command line (should work in python 2 or 3). The output containing the alignment files can be found in the folder `STAR_output`.

### Understanding ReadsPerGene.out.tab

In the STAR_output folder, you will find a folder of results for each one of the FASTQ files you mapped. Inside each folder, you will find: 

```{}
Aligned.sortedByCoord.out.bam
Log.final.out
Log.out
Log.progress.out
ReadsPerGene.out.tab
SJ.out.tab
```

The file that contains the data you need is `ReadsPerGene.out.tab`. This file contains the number of reads that mapped to each gene in the transcriptome. A quick glance at the file using the command below shows the structure of the file, in which there are some QC metrics at the beginning of the file (N_unmapped, etc.) followed by each gene in the transcriptome. 

```ba
cat ReadsPerGene.out.tab | head -n 10
```

```{}
N_unmapped	2461926	2461926	2461926
N_multimapping	4255262	4255262	4255262
N_noFeature	4048236	41792820	4475290
N_ambiguous	3081395	50727	1691846
ENSG00000223972	0	0	0
ENSG00000227232	3	0	3
ENSG00000278267	13	0	13
ENSG00000243485	0	0	0
ENSG00000284332	0	0	0
ENSG00000237613	0	0	0
```

The first column corresponds to the ensembl gene ID, and columns 2, 3, and 4 correspond to the counts mapped for each gene. You might be wondering why there are 3 columns of counts-- each column corresponds to the "strandedness" of the read mapping. An RNA-seq library is composed of DNA, which has two strands: a "sense" strand and an "anti-sense" strand. RNA-sequencing libraries can be prepared as either "unstranded" or "stranded". The column you choose for downstream analysis is typically dictated by the type of library kit that was used to prepare the samples.

* If an "unstranded" library prep kit was used, column 2 should be selected. In this case, we don't know which strand the original mRNA was produced from, and reads are mapped to both the sense and anti-sense strand.

* If a "stranded" library prep kit was used, we must choose from column 3 or 4. The information from which strand the mRNA originated from is retained. Column 3 corresponds to the first read strand aligned, and column 4 corresponds to the second read strand aligned.

Looking at the sample information at https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSM3145522, we see that the TruSeq® Stranded mRNA Library Prep Kit (RS-122-2101, Illumina) was used to prepare the samples. Since this is a stranded library prep kit, we must select from column 3 or 4. Looking at the output, we observe that column 4 contains the reads whereas column 3 does not. We will proceed with using column 4 from each of the samples for downstream analysis.

### combining read counts from each sample

There is an folder for each one of our samples. We need to combine column 4 in `ReadsPerGene.out.tab` for each of the samples into one data file. To do so, we can loop through each of the `ReadsPerGene.out.tab` files in Python and extract information from the column corresponding to the correct strand using the code below.

```py
import os
import csv

# modify desired_column based on strandedness of library kit
desired_column = 3
output_directory = "STAR_output/"
sample_dict = {}
sample_names = []

# loop through each folder and store data from ReadsPerGene.out.tab in sample_dict
for folder in os.listdir(output_directory):
    if folder.endswith("_output"):
        file_name=folder.strip('_output')
        sample_names.append(file_name)
        gene_dict = {}
        with open(output_directory + folder + "/ReadsPerGene.out.tab") as tabfile:
            print("Column " + str(desired_column) + " of " + file_name + " stored")
            reader = csv.reader(tabfile, delimiter = "\t")
            for row in reader:
                gene_dict[row[0]]=row[desired_column]
        # store gene_dict for the current file in sample_dict
        sample_dict[file_name] = gene_dict

# write sample_dict to output files
# the qc metrics are stored in qc.csv, and the gene counts are stored in raw_counts.csv
with open("raw_counts.csv", "wt") as counts_file, open("qc.csv", "wt") as qc_file:
    counts_writer = csv.writer(counts_file)
    qc_writer = csv.writer(qc_file)
    counts_writer.writerow( ['ensembl_id']+ sample_names )
    qc_writer.writerow( ['qc_metric']+ sample_names )
    sorted_genes = sorted(list(sample_dict[sample_names[0]].keys()))
    for gene in sorted_genes:
        output=[gene]
        for sample in sample_names:
            output.append(sample_dict[sample][gene])
        if gene.startswith("N_"):
            qc_writer.writerow(output)
        else:
            counts_writer.writerow(output)
```

The code outputs a file called `raw_counts.csv`, with 9 columns. The first column is the Ensembl ID of each of the genes in the transcriptome. The rest of the columns correspond to the counts per gene for the 8 samples. Another file named `qc.csv` is created containing the qc metrics that were at the beginning of the `ReadsPerGene.out.tab` file for each sample.

## Performing Differential Gene Expression Analysis

DESeq2 explanation: in order to perform differential gene analysis using the R package DESeq2, from bioconductor. 

A great tutorial that goes into the nitty-gritty details of this analysis can be found here: https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html. My analysis below is an example of the workflow that a scientist would use to analyze their RNA-seq data.

Installing DESeq2:

```{r eval=F}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("DESeq2")
```

### Loading data and packages

```{r}
library("DESeq2")
library("tidyverse")
```

We can now load `raw_counts.csv` into R, and take a look at the structure of the data

```{r}
data <- read.csv("raw_counts.csv", header = T)
data <- data[,sort(colnames(data))]
head(data)
```

```{r}
dim(data)
```

We observe that there are 60676 rows and 9 columns to the data, in which each row is a gene and each column corresponds to the reads per gene for each sample. This is the format that is appropriate for the DESeq2 package. It would be nice to have each Ensembl ID translated into its gene name. We can build an annotation file using the BioMart at ensembl.org, which I'll explain in the following section.

### Making an annotation file from BioMart

A genome annotation file wil let us map ensembl IDs to their gene names. To build one:

1. First go to the ensembl BioMart at http://uswest.ensembl.org/biomart/martview/
2. Choose the database to use, in this case "Ensembl Genes 99" or whatever is the current version
3. Choose an annotation to use, in this case "Human Genes (GRCh38.p13) 
4. On the left sidebar, click "Attributes", which will allow you to select the items you want to map. The items you want are "Gene stable ID", (which is the ensemble id in our raw_counts.csv file), and "Gene name". You can un-check "Gene stable ID version", "Transcript stable ID", and "Transcript stable ID version". You can also choose to include other attributes of your liking, such as "Gene type" to know which genes are protein-coding. If we want to perform Gene Set Enrichment Analysis (GSEA) downstream, we will need this category.
5. Click on results, check "unique results only", select export as csv, and hit the "Go" button!

The annotation should download to your computer as "mart_export.txt". We can rename it to "GRCh38.p13_annotation.csv" read it into R:

```{r}
human_annotation <- read.csv("GRCh38.p13_annotation.csv", header = T, stringsAsFactors = F)
head(human_annotation)
```

We observe that there are two columns, one named "Gene.stable.ID" which is contains the ensembl IDs, and a second column named "Gene.name" which contains the gene names that we want to map to our `raw_counts.csv` file. To map the names, we can join the two tables based on the ensembl IDs using the `right_join()` function from the tidyverse.

```{r}
annotated_data <- right_join(human_annotation, data, by = c("Gene.stable.ID" = "ensembl_id"))
annotated_data
write.csv(annotated_data, file = "gene_annotated_raw_counts.csv")
```

### Creating the DESeq2 object

To create the DESeq2 object, we can use the function `DESeqDataSetFromMatrix`, which requires three items:

1. countData - The data in the form of an integer matrix, in which the rownames correspond to the gene IDs. 
2. colData - A table that provides the sample groups and identifies which samples fall in each group (i.e. biological replicates).
3. design - A formula that expressed how the counts for each gene depend on the variables in colData. Typically if you are just comparing between groups, we can use the groups defined in colData.

```{r}
# make a counts matrix in which rownames are ensembl ids
my_countData <- column_to_rownames(data, "ensembl_id")

# identify biological replicates
condition <- c(rep("LNCAP_Hypoxia", 2), rep("LNCAP_Normoxia", 2), rep("PC3_Hypoxia", 2), rep("PC3_Normoxia", 2))

# assign replicates to each sample name
my_colData <- as.data.frame(condition)
rownames(my_colData) <- colnames(data[,-1])
my_colData
```

Now that we have these the required inputs, we can run `DESeqDataSetFromMatrix`

```{r}
dds <- DESeqDataSetFromMatrix(countData = my_countData,
							  colData = my_colData,
							  design = ~condition)
```

This can immediately be processed using the `DESeq()`, which will perform differential expression analysis based on a negative binomial distribution. From the documentation, this function will perform:

1. estimation of size factors: estimateSizeFactors
2. estimation of dispersion: estimateDispersions
3. Negative Binomial GLM fitting and Wald statistics: nbinomWaldTest

More information about what goes into this processing step can be found here: https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html

```{r}
dds <- DESeq(dds)
```

We can observe some basic information about the dds object just by calling its name:

```{r}
dds
```

We can also sift through the dds object using `@` and `$`. For example, we can find the raw counts data that was used to create the dds object at:

```{r}
head(dds@assays$data@listData$counts)
```

## Visualizations: sample variability

At this point, we can start to assess sample to sample variability. DESeq2 has some built-in functions that can be used to do so, including distance plots and PCA plots. In order to use these functions, we first perform a variance stabilizing transformation on the data using `vst()`:

```{r}
vsd <- vst(dds, blind = TRUE)
```

We can plug the variance stabilized object into the following functions:

### 1. Distance Plot

```{r}
plotDists = function (vsd.obj) {
  sampleDists <- dist(t(assay(vsd.obj)))
  sampleDistMatrix <- as.matrix( sampleDists )
  rownames(sampleDistMatrix) <- paste( vsd.obj$condition )
  colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
  pheatmap(sampleDistMatrix,
           clustering_distance_rows = sampleDists,
           clustering_distance_cols = sampleDists,
           col = colors)
}
plotDists(vsd)
```

### 2. PCA Plot

```{r}
name.plotPCA = function (vsd.obj) {
  pcaData <- plotPCA(vsd.obj,  intgroup = c("condition"), returnData = T)
  percentVar <- round(100 * attr(pcaData, "percentVar"))
  ggplot(pcaData, aes(PC1, PC2, color=condition)) +
    geom_point(size=3) +
    labs(x = paste0("PC1: ",percentVar[1],"% variance"),
         y = paste0("PC2: ",percentVar[2],"% variance"),
         title = "PCA Plot colored by condition") +
    geom_text_repel(aes(label = name), color = "black")
}

name.plotPCA(vsd)
```

### 3. Variable Genes Heatmap

```{r}

vsd.obj = lncap_vsd

plotHeatmap <- function (vsd.obj, num_genes = 500, annotation) {
  brewer_palette <- "RdBu"
  # Ramp the color in order to get the scale.
  ramp <- colorRampPalette(brewer.pal(11, brewer_palette))
  mr <- ramp(256)[256:1]
  # get the stabilized counts from the vsd object
  stabilized_counts <- assay(vsd.obj)
  # calculate the variances by row(gene) to find out which genes are the most variable across the samples.
  row_variances <- rowVars(stabilized_counts)
  # get the top most variable genes
  top_variable_genes <- stabilized_counts[order(row_variances, decreasing=T)[1:num_genes],]
  # subtract out the means from each row, leaving the variances for each gene
  top_variable_genes <- top_variable_genes - rowMeans(top_variable_genes, na.rm=T)
  # replace the ensembl ids with the gene names
  gene_names <- annotation$Gene.name[match(rownames(top_variable_genes), annotation$Gene.stable.ID)]
  rownames(top_variable_genes) <- gene_names
  # reconstruct colData without sizeFactors for heatmap labeling
  coldata <- as.data.frame(vsd.obj@colData)
  coldata$sizeFactor <- NULL
  # draw heatmap using pheatmap
  my_heatmap <- pheatmap(top_variable_genes, color = mr, annotation_col = coldata, fontsize_col = 5, fontsize_row = 250/num_genes, fontsize = 5, border_color = NA)
  my_heatmap
}

plotHeatmap(vsd, annotation = human_annotation)
plotHeatmap(vsd, num_genes = 30, annotation = human_annotation)
plotHeatmap(vsd, num_genes = 100, annotation = human_annotation)

```

### Create individual dds objects

Because a lot of the variability in the data is due to the cell line difference, and because the biological comparisons that we want to make are only within either LNCaP, we will create an individual dds object for just LNCaP samples and and just the PC3 samples. The function generate_DESeq_object() below will make a dds object using your raw counts data and the groups that you want to compare. So far, this function can only do groups of 2. It will select the columns out from the raw data that match the group designations using `grep()`, build the colData matrix based on your group designations and the samples it selected, then generate and process the dds object using `DESeqDataSetFromMatrix()` and `DESeq()`.

```{r}
generate_DESeq_object <- function (my_data, groups) {
  my_data <- column_to_rownames(my_data, "ensembl_id")
  data_subset1 <- my_data[,grep(str_c("^", groups[1]), colnames(my_data))]
  data_subset2 <- my_data[,grep(str_c("^", groups[2]), colnames(my_data))]
  my_countData <- cbind(data_subset1, data_subset2)
  condition <- c(rep(groups[1],ncol(data_subset1)), rep(groups[2],ncol(data_subset2)))
  my_colData <- as.data.frame(condition)
  rownames(my_colData) <- colnames(my_countData)
  print(my_colData)
  dds <- DESeqDataSetFromMatrix(countData = my_countData,
  							  colData = my_colData,
  							  design = ~ condition)
  dds <- DESeq(dds)
  return(dds)
}

lncap <- generate_DESeq_object(data, c("LNCAP_Hypoxia", "LNCAP_Normoxia"))
pc3 <- generate_DESeq_object(data, c("PC3_Hypoxia", "PC3_Normoxia"))
```

We can double check to make sure that the appropriate columns have been selected and that the colData is correct.

```{r}
lncap@colData
head(lncap@assays$data@listData$counts)
```

```{r}
lncap_vsd <- vst(lncap, blind = T)
pc3_vsd <- vst(pc3, blind = T)
```

```{r}
plotHeatmap(lncap_vsd, 50, annotation = human_annotation)
plotHeatmap(pc3_vsd, 50, annotation = human_annotation)
```



### extract results from dds object

```{r}
generate_DE_results <- function (dds, comparisons, fdrcutoff = 0.001, rawpcutoff = 0.001, log2cutoff = 0.5, cpmcutoff = 2) {
  # generate average counts per million metric from raw count data 
  raw_counts <- counts(dds, normalized = F)
  cpms <- enframe(rowMeans(cpm(raw_counts)))
  colnames(cpms) <- c("ensembl_id", "avg_cpm")
  
  # extract DESeq results between the comparisons indicated
  res <- results(dds, contrast = c("condition", comparisons[1], comparisons[2]))[,-c(3,4)]
  
  # annotate the data with gene name and average counts per million value
  res <- as_tibble(res, rownames = "ensembl_id")
  # read in the annotation and append it to the data
  my_annotation <- read.csv("GRCh38.p13_annotation.csv", header = T, stringsAsFactors = F)
  res <- left_join(res, my_annotation, by = c("ensembl_id" = "Gene.stable.ID"))
  # append the average cpm value to the results data
  res <- left_join(res, cpms, by = c("ensembl_id" = "ensembl_id"))
  
  # combine normalized counts with entire DE list
  normalized_counts <- round(counts(dds, normalized = TRUE),3)
  pattern <- str_c(comparisons[1], "|", comparisons[2])
  combined_data <- as_tibble(cbind(res, normalized_counts[,grep(pattern, colnames(normalized_counts))] ))
  combined_data <- combined_data[order(combined_data$log2FoldChange, decreasing = T),]
  
  # make ordered rank file for GSEA, selecting only protein coding genes
  res_prot <- res[which(res$Gene.type == "protein_coding"),]
  res_prot_ranked <- res_prot[order(res_prot$log2FoldChange, decreasing = T),c("Gene.name", "log2FoldChange")]
  res_prot_ranked <- na.omit(res_prot_ranked)
  res_prot_ranked$Gene.name <- str_to_upper(res_prot_ranked$Gene.name)
  
  # generate sorted lists with the indicated cutoff values
  res <- res[order(res$log2FoldChange, decreasing=TRUE ),]
  de_genes_fdr <- res[which(res$padj < fdrcutoff),]
  de_genes_rawp <- res[which(res$pvalue < rawpcutoff),]
  de_genes_log2f <- res[which(abs(res$log2FoldChange) > log2cutoff & res$padj < fdrcutoff),]
  de_genes_cpm <- res[which(res$avg_cpm > cpmcutoff & res$padj < fdrcutoff),]
  
  # write output to files
  write.csv (de_genes_fdr, file = paste0(comparisons[1], "_vs_", comparisons[2], "_fdrgenes.csv"), row.names =F)
  write.csv (de_genes_rawp, file = paste0(comparisons[1], "_vs_", comparisons[2], "_rawpgenes.csv"), row.names =F)
  write.csv (de_genes_log2f, file = paste0(comparisons[1], "_vs_", comparisons[2], "_log2f.csv"), row.names =F)
  write.csv (de_genes_cpm, file = paste0(comparisons[1], "_vs_", comparisons[2], "_cpm_cutoff.csv"), row.names =F)
  write.csv (combined_data, file = paste0(comparisons[1], "_vs_", comparisons[2], "_allgenes.csv"), row.names =F)
  write.table (res_prot_ranked, file = paste0(comparisons[1], "_vs_", comparisons[2], "_rank.rnk"), sep = "\t", row.names = F, quote = F)
  
  writeLines( paste0("For the comparison: ", comparisons[1], "_vs_", comparisons[2], ", out of ", nrow(combined_data), " genes, there were: \n", 
               nrow(de_genes_rawp), " genes below p-value ", rawpcutoff, "\n",
               nrow(de_genes_fdr), " genes below padj ", fdrcutoff, "\n",
               nrow(de_genes_log2f), " genes below padj ", fdrcutoff, " and above a log2FoldChange of ", log2cutoff, "\n",
               nrow(de_genes_cpm), " genes below padj ", fdrcutoff, " and above an avg cpm of ", cpmcutoff, "\n",
               "Differential expression gene lists ordered by log2fchange with the cutoffs above have been generated.") )
  gene_count <- tibble (cutoff_parameter = c("pvalue", "padj", "log2fc", "avg_cpm" ), 
                        cutoff_value = c(rawpcutoff, fdrcutoff, log2cutoff, cpmcutoff), 
                        signif_genes = c(nrow(de_genes_rawp), nrow(de_genes_fdr), nrow(de_genes_log2f), nrow(de_genes_cpm)))
  invisible(gene_count)
}

lncap_output <- generate_DE_results (lncap, c("LNCAP_Hypoxia", "LNCAP_Normoxia"))
pc3_output <- generate_DE_results(pc3, c("PC3_Hypoxia", "PC3_Normoxia"))

lncap_output
pc3_output
```

### exploring the results ouptut

Explain column by column and how we got it from the above code

```{r}
res <- read.csv ("LNCAP_Hypoxia_vs_LNCAP_Normoxia_allgenes.csv", header = T)
res
```


## Visualizations

### 1. PlotCounts (Upgraded)

The built-in plotCounts function in DESeq2 leaves a lot to be desired:


```{r}
plotCounts(dds, gene=which.min(res$padj), intgroup="condition")

```

We can extract the data using `returnData = T`, and plot it using ggplot2:

```{r}


d <- plotCounts(dds, gene=which.min(res$padj), intgroup="condition", 
                returnData=TRUE)
d
ggplot(d, aes(x=condition, y=count)) + 
  geom_point(position=position_jitter(w=0.1,h=0), aes (color = condition)) + 
  scale_y_log10(breaks=c(25,100,400))

```

But even this function is hard to work with, since we have to input the ensembl id instead of a gene name. As a researcher, we typically want to search by gene name, and this forces us to look up the ensembl genes each time. To work around this, I re-wrote plotCounts to accept either the gene name, ensembl id, or an index such as the example with which.min(res$padj), below. I also provide two ways to normalize the data - counts per million or the built-in DESeq2 normalized counts.

```{r}
plot_counts <- function (dds, gene, normalization = "DESeq2"){
  if (normalization == "cpm") {
    normalized_data <- cpm(counts(dds, normalized = F)) # normalize the raw data by counts per million
  } else if (normalization == "DESeq2")
    normalized_data <- counts(dds, normalized = T) # use DESeq2 normalized counts
  # get sample groups from colData
  condition <- dds@colData$condition
  # get the gene name from the ensembl id
  if (is.numeric(gene)) { # check if an index is supplied or if ensembl_id is supplied
    if (gene%%1==0 )
      ensembl_id <- rownames(normalized_data)[gene]
    else
      stop("Invalid index supplied.")
  } else if (gene %in% annotation$Gene.name){ # check if a gene name is supplied
    ensembl_id <- annotation$Gene.stable.ID[which(annotation$Gene.name == gene)]
  } else if (gene %in% annotation$Gene.stable.ID){
    ensembl_id <- gene
  } else {
    stop("Gene not found. Check spelling.")
  }
  expression <- normalized_data[ensembl_id,]
  gene_name <- annotation$Gene.name[which(annotation$Gene.stable.ID == ensembl_id)]
  # construct a tibble with the grouping and expression
  gene_tib <- tibble(condition = condition, expression = expression)
  ggplot(gene_tib, aes(x = condition, y = expression))+
    geom_boxplot(outlier.size = NULL)+
    geom_point()+
    labs (title = paste0("Expression of ", gene_name, " - ", ensembl_id), x = "group", y = paste0("Normalized expression (", normalization , ")"))+
    theme(axis.text.x = element_text(size = 11), axis.text.y = element_text(size = 11))
}

plot_counts(dds, "GSTA1")
plot_counts(dds, "ENSG00000000419")
plot_counts(dds, gene = which.min(res$padj))

```


### 2. Volcano Plot


```{r}
res <- read.csv ("LNCAP_Hypoxia_vs_LNCAP_Normoxia_allgenes.csv", header = T)

plot_volcano = function (res, padj_cutoff, nlabel = 10, label.by = "padj"){
  res <- mutate(res, significance=ifelse(res$padj<padj_cutoff, paste0("padj < ", padj_cutoff), paste0("padj > ", padj_cutoff)))
  res = res[!is.na(res$significance),]
  significant_genes <- res %>% filter(significance == paste0("padj < ", padj_cutoff))
  
  if (label.by == "padj") {
    top_genes <- significant_genes %>% arrange(padj) %>% head(nlabel)
    bottom_genes <- significant_genes %>% filter (log2FoldChange < 0) %>% arrange(padj) %>% head (nlabel)
  } else if (label.by == "log2FoldChange") {
    top_genes <- head(arrange(significant_genes, desc(log2FoldChange)),nlabel)
    bottom_genes <- head(arrange(significant_genes, log2FoldChange),nlabel)
  } else
    stop ("Invalid label.by argument. Choose either padj or log2FoldChange.")
  
  ggplot(res, aes(log2FoldChange, -log(padj))) +
    geom_point(aes(col=significance)) + 
    scale_color_manual(values=c("red", "black")) + 
    geom_text_repel(data=top_genes, aes(label=head(Gene.name,nlabel)), size = 3)+
    geom_text_repel(data=bottom_genes, aes(label=head(Gene.name,nlabel)), color = "#619CFF", size = 3)+
    labs ( x = "Log2FoldChange", y = "-(Log normalized p-value)")+
    geom_vline(xintercept = 0, linetype = "dotted")+
    theme_minimal()
}

plot_volcano(res, 0.0005, nlabel = 20, label.by = "padj")
plot_volcano(res, 0.0005, nlabel = 10, label.by = "log2FoldChange")


```

### 3. Differential gene heatmap

Take the top 50 DE genes from res object and then plot a heatmap using the normalized expression values (can extract from the csv file - filtered first by padj and then ranked by log2fc)

```{r}
DE_gene_heatmap <- function(res, padj_cutoff = 0.0001, ngenes = 20) {
  brewer_palette <- "RdBu"
  # Ramp the color in order to get the scale.
  ramp <- colorRampPalette(brewer.pal(11, brewer_palette))
  mr <- ramp(256)[256:1]
  significant_genes <- res %>% filter(padj < padj_cutoff) %>% arrange (desc(log2FoldChange)) %>% head (ngenes)
  heatmap_values <- as.matrix(significant_genes[,-c(1:8)])
  rownames(heatmap_values) <- significant_genes$Gene.name
  pheatmap(heatmap_values, color = mr, scale = "row", fontsize_col = 10, fontsize_row = 200/ngenes, fontsize = 5, border_color = NA)
}
DE_gene_heatmap(res, 0.001, 30)

```


### 4. LogFC comparison plot

Compares the list of DE genes that are unique to comparison 1 vs comparison 2 vs shared by both comparisons


```{r}
res1 <- read.csv ("LNCAP_Hypoxia_vs_LNCAP_Normoxia_allgenes.csv", header = T)
res2 <- read.csv ("PC3_Hypoxia_vs_PC3_Normoxia_allgenes.csv", header = T)

compare_significant_genes <- function (res1, res2, padj_cutoff=0.0001, ngenes=250, nlabel=10, samplenames=c("comparison1", "comparison2"), title = "" ) {
  # get list of most upregulated or downregulated genes for each results table
  genes1 <- rbind(head(res1[which(res1$padj < padj_cutoff),], ngenes), tail(res1[which(res1$padj < padj_cutoff),], ngenes))
  genes2 <- rbind(head(res2[which(res2$padj < padj_cutoff),], ngenes), tail(res2[which(res2$padj < padj_cutoff),], ngenes))
  
  # combine the data from both tables
  de_union <- union(genes1$ensembl_id,genes2$ensembl_id)
  res1_union <- res1[match(de_union, res1$ensembl_id),][c("ensembl_id", "log2FoldChange", "Gene.name")]
  res2_union <- res2[match(de_union, res2$ensembl_id),][c("ensembl_id", "log2FoldChange", "Gene.name")]
  combined <- left_join(res1_union, res2_union, by = "ensembl_id", suffix = samplenames )
  
  # identify overlap between genes in both tables
  combined$de_condition <- 1 # makes a placeholder column
  combined$de_condition[which(combined$ensembl_id %in% intersect(genes1$ensembl_id,genes2$ensembl_id))] <- "Significant in both"
  combined$de_condition[which(combined$ensembl_id %in% setdiff(genes1$ensembl_id,genes2$ensembl_id))] <- paste0("Significant in ", samplenames[1])
  combined$de_condition[which(combined$ensembl_id %in% setdiff(genes2$ensembl_id,genes1$ensembl_id))] <- paste0("Significant in ", samplenames[2])
  combined[is.na(combined)] <- 0
  
  # find the top most genes within each condition to label on the graph
  label1 <- rbind(head(combined[which(combined$de_condition==paste0("Significant in ", samplenames[1])),],nlabel),
                  tail(combined[which(combined$de_condition==paste0("Significant in ", samplenames[1])),],nlabel))
  label2 <- rbind(head(combined[which(combined$de_condition==paste0("Significant in ", samplenames[2])),],nlabel),
                  tail(combined[which(combined$de_condition==paste0("Significant in ", samplenames[2])),],nlabel))
  label3 <- rbind(head(combined[which(combined$de_condition=="Significant in both"),],nlabel),
                  tail(combined[which(combined$de_condition=="Significant in both"),],nlabel))
  combined_labels <- rbind(label1,label2,label3)
  
  # plot the genes based on log2FoldChange, color coded by significance
  ggplot(combined, aes_string(x = paste0("log2FoldChange", samplenames[1]), y = paste0("log2FoldChange", samplenames[2]) )) +
      geom_point(aes(color = de_condition), size = 0.7)+
      scale_color_manual(values= c("#00BA38", "#619CFF", "#F8766D"))+
      geom_text_repel(data= combined_labels, aes_string(label=paste0("Gene.name", samplenames[1]), color = "de_condition"), show.legend = F, size=3)+
      geom_vline(xintercept = c(0,0), size = 0.3, linetype = 2)+ 
      geom_hline(yintercept = c(0,0), size = 0.3, linetype = 2)+
      labs(title = title,x = paste0("log2FoldChange in ", samplenames[1]), y = paste0("log2FoldChange in ", samplenames[2]))+
      theme_minimal()+
      theme(legend.title = element_blank())
}

compare_significant_genes(res1,res2, samplenames = c("LNCaP", "PC3"), title = "Hypoxia-induced gene expression differences in LNCaP vs PC3 cells")  
```

### 5. Gene set enrichment analysis (GSEA)

Gene Set Enrichment Analysis (GSEA) can be used to test whether pathways consisting of a collection of multiple genes are enriched in one group compared to another. For example, there is a "gene set" of 200 genes that compose the hypoxia pathway. Although one specific gene in the pathway may not be statistically significant in your differential gene expression analysis, the pathway composed of all of the genes could be significantly enriched.

GSEA is useful if there are only subtle changes in your dataset, and you want to determine if groups of genes as a collective are significantly altered. For this particular analysis, we would like to determine whether the genes associated with the hypoxia pathway are upregulated in the hypoxia condition, as a way to check that the experiment was performed correctly.

To perform GSEA, we have to rank every gene available in terms of how much higher or lower it is in group A vs group B. This is called a ranked list file, and we have already generated one in the above section using the function `generate_DE_results()`. Then, we plug this list of genes into either the GSEA application from the Broad Institute (https://www.gsea-msigdb.org/gsea/index.jsp), or into the R package ```fgsea``` from Bioconductor (https://bioconductor.org/packages/release/bioc/html/fgsea.html). If you choose to use the GSEA application rather than the R package, the rank files have to be in a very specific format. The genes must be all upper-case, and there can only be a column for the gene name and its corresponding average log-foldchange. Below is some code that will generate rank files that can be used in either application.

To use the R package `fgsea`, you can install using the commands:

```{r}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("fgsea")
```

We also have to download the pathway files from the GSEA MSigDB webpage at: https://www.gsea-msigdb.org/gsea/msigdb/collections.jsp and load them in using ```fgsea::gmtPathways```. A commonly-used set of pathways is the HALLMARK pathway set, which I will use below.

```{r message=F, warning=F}
library(fgsea)
# read in file containing lists of genes for each pathway
hallmark_pathway <- gmtPathways("h.all.v7.0.symbols.gmt.txt")
head(names(hallmark_pathway))
```

Then, we have to turn our ranked list into a vector in which the log2FoldChange value is named with the gene name, as well as get rid of any NA values or duplicate gene entries.

```{r}
# load the ranked list
lncap_ranked_list <- read.table("LNCAP_Hypoxia_vs_LNCAP_Normoxia_rank.rnk", header = T, stringsAsFactors = F)
lncap_ranked_list

# formats the ranked list for the fgsea() function
prepare_ranked_list <- function(ranked_list) { 
  # if duplicate gene names present, average the values
  if( sum(duplicated(ranked_list$Gene.name)) > 0) {
    ranked_list <- aggregate(.~Gene.name, FUN = mean, data = ranked_list)
    ranked_list <- ranked_list[order(ranked_list$log2FoldChange, decreasing = T),]
  }
  # omit rows with NA values
  ranked_list <- na.omit(ranked_list)
  # turn the dataframe into a named vector
  ranked_list <- tibble::deframe(ranked_list)
  ranked_list
}

lncap_ranked_list <- prepare_ranked_list(lncap_ranked_list)
head(lncap_ranked_list)
```

Now that we have the named vector, we can plug it into the fgsea() function along with the hallmark pathways object. This will generate a table of results containing the enrichment scores associated with each pathway.

```{r}
# generate GSEA result table using fgsea() by inputting the pathway list and ranked list
fgsea_results <- fgsea(pathways = hallmark_pathway,
                  stats = lncap_ranked_list,
                  minSize = 15,
                  maxSize = 500,
                  nperm= 1000)

fgsea_results %>% arrange (desc(NES)) %>% select (pathway, padj, NES) %>% head()
```

The normalized enrichment scores (NES) tell us how much higher the pathway is in the Hypoxia samples vs the Normoxia samples. In this case, we observe that the most enriched pathway in response to hypoxia, as expected, is the HALLMARK_HYPOXIA pathway.

In order to visualize the enrichment level and p-values for each pathway, we can construct a "waterfall" plot, which is a sideways bar plot of normalized enrichment scores for each of the pathways. The significantly enriched pathways are highlighted in a different color.

```{r}
waterfall_plot <- function (fsgea_results, graph_title) {
  fgsea_results %>% 
    mutate(short_name = str_split_fixed(pathway, "_",2)[,2])%>%
    ggplot( aes(reorder(short_name,NES), NES)) +
      geom_bar(stat= "identity", aes(fill = padj<0.05))+
      coord_flip()+
      labs(x = "Hallmark Pathway", y = "Normalized Enrichment Score", title = graph_title)+
      theme(axis.text.y = element_text(size = 7), 
            plot.title = element_text(hjust = 1))
}

waterfall_plot(fgsea_results, "Hallmark pathways altered by hypoxia in LNCaP cells")
```

Using this visualization, it is easy to quickly identify the significantly enriched pathways. Again, we observe that hypoxia is the most enriched pathway in hypoxic LNCaP cells. The androgen response and MTORC1 signaling also appear to be significantly enriched in hypoxic conditions. Interestingly the interfereon gamma and interfereon alpha response pathways are both greatly negatively enriched in hypoxic conditions, suggesting that the signaling pathways associated with these reponses are shut down compared to cells grown in normoxic conditions.

We can narrow in on specific pathways of interest. Another way to visualize the enrichment score is using an "enrichment curve", which we can plot using ```fgsea::plotEnrichment()```. In these plots, the black ticks on the x-axis indicate a gene in the pathway, and the green curve is a measure of how enriched the genes are for either the Hypoxia group (left side) or the Normoxia group (right side). An example of pathways highly enriched in either the Hypoxia or Normoxia groups are below.

```{r}
# wrapper for fgsea::plotEnrichment()
plot_enrichment <- function (geneset, pathway, ranked_list) {
  plotEnrichment(geneset[[pathway]], ranked_list)+labs (title = pathway)
}
# example of positively enriched pathway (up in Hypoxia)
plot_enrichment(hallmark_pathway,"HALLMARK_HYPOXIA", lncap_ranked_list)
plot_enrichment(hallmark_pathway, "HALLMARK_GLYCOLYSIS" , lncap_ranked_list)
# example of negatively enriched pathway (up in Normoxia)
plot_enrichment(hallmark_pathway, "HALLMARK_OXIDATIVE_PHOSPHORYLATION" , lncap_ranked_list)
```


## Conclusion